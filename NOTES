# -*-org-*-

* Control Groups

We'd like to be able to run genapp applications in Linux containers.

But how?

We have some experience running cgroups with the help of tools like
cgconfig. This works well, but has a couple problems we might try to avoid:

- More software to require (bundle, install, manage, etc.)
- Move moving parts to troubleshoot when something goes wrong

* genapp Extensions

We're currently hard coding some genapp facilities:

- genapp services require runit tools (runsv, chpst, sv)

If we added support for them, these too might be hard coded:

- Control groups
- Linux containers

How many steps would it take to move from simple, hard-coding to something more
flexible?

The benefit to flexible configuration is that genapp developers can tailor
their genapp usage to what's needed or to what's available. This makes genapp
more portable and easier to get started with.

The current "devmode" setting is a naive attempt to remove onerous requirements
(e.g. privileged user access and runit tools) so new genapp developers can more
easily use the tool.

** Extension Points

I'm thinking this is defined by a behavior.

Let's call it ~genapp_extension~ for now.

This would be a flexible behavior so that moduled could implement functional
subsets. Developers can configure multiple extensions, each playing a role.

#+begin_src erlang
  -module(genapp_extension).

  -export([behaviour_info/1]).

  behaviour_info(callbacks) -> [].
#+end_src

Extensions could be defined in config this way:

#+begin_src erlang
  [{genapp, [{extensions, [runit, cgroups]}]}].
#+end_src

If an extension required config, it could be done this way:

#+begin_src erlang
  [{genapp,
    [{extensions, [runit, cgroups]},
     {runit, [{services_home, "/var/genapp/services"}]}]}].
#+end_src

*** Run command as a particular user

We're currently hard coding a dependency on ~chpst~.

This could be the more traditional ~su~.

Or it could be something else.

But mainly I don't think we want to require chpst to run genapp, if we can
avoid it.

Function:

    run_as(User, Cmd, Args, Options, Timeout) -> Result
    run_as({User, Group}, Cmd, Args, Options, Timeout) -> Result
